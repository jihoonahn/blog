<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>JiHoonAHN Blog</title><description>This is a personal blog for iOS Developer JiHoonAHN.</description><link>https://blog.jihoon.me</link><language>en</language><lastBuildDate>Tue, 25 Oct 2022 14:36:38 +0900</lastBuildDate><pubDate>Tue, 25 Oct 2022 14:36:38 +0900</pubDate><ttl>250</ttl><atom:link href="https://blog.jihoon.me/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://blog.jihoon.me/posts/4</guid><title>RIBs</title><description>Let's study the RIBs made by Uber!</description><link>https://blog.jihoon.me/posts/4</link><pubDate>Tue, 25 Oct 2022 14:09:00 +0900</pubDate><content:encoded><![CDATA[<p>Uber에서 만든 RIBs에 대해서 공부해 보겠습니다.</p><h3>What is RIBs?</h3><p>RIBs는 Uber에서 만든 cross-platform Mobile Architecture Framework 입니다.</p><p>공식 Github : <a href="https://github.com/uber/RIBs">RIBs</a></p><img width="100%"  alt="my-option" src="https://github.com/uber/ribs/raw/assets/documentation/ribs.png">
</img><p>RIBs는 Router, Interactor, Builder의 약자입니다.</p><p>하나의 RIB은 Router, Interactor, Builder를 필수적으로 구현해야하고 View와 Presenter는 필요에 따라 구성됩니다.</p><hr><h3>각각의 역할</h3><p><strong>Builder</strong></p><ul><li>RIBs 의 모든 구성요소를 생성하고 DI를 정의합니다. 즉 Router, Interactor, View, Component를 모두 생성합니다.</li></ul><p><strong>Component</strong></p><ul><li>부모 RIB의 Builder가 Component를 통해 자식 RIB의 Builder로 의존성 주입시켜줍니다.</li></ul><p><strong>Router</strong></p><ul><li>자식 RIB를 attach, detach하여 RIBs 논리적 트리 구조를 형성합니다.</li></ul><p><strong>Interactor</strong></p><ul><li>Business logic을 수행하며 Router로 Routing call 그리고 RIBs의 attach와 detach를 요청하거나, Presenter로 Data model를 전달합니다.</li></ul><p><strong>View</strong></p><ul><li>UI를 담당하는 로직입니다.</li><li>UI Event를 Presenter로 전달하거나 View model을 받아서 UI를 업데이트합니다.</li></ul><p><strong>Presenter</strong></p><ul><li>Interactor와 View간의 통신을 담당하며, Business model을 View model을 변환하는 역할로 상태를 가지고 있지 않은 클래스입니다. Presenter를 생략하는 경우 View model 변환의 책임은 View 또는 Interactor가 되어야 합니다.</li></ul><hr><p>필요에 따라 Presenter와 View가 구성된다의 의미는, VIPER 패턴과 달리 View가 포함되지 않고 비즈니스 로직으로만 구성된 Viewless RIB의 생성이 가능하다는 의미입니다.</p><h3>RIBs Tree</h3><img width="100%"  alt="my-option" src = "https://github.com/uber/ribs/raw/assets/documentation/state.gif"></img><p>RIBs는 논리적 트리구조를 형상하여, 부모 RIB와 자식 RIB 간의 통신을 합니다.</p><p>RIBs 간의 통신은 Interactor가 담당합니다.</p><p>부모와 자식간의 소통은 Observable Stream을 넘겨주어서 데이터를 전달합니다.</p><p>자식에서 부모로의 통신은 자식 Interactor에서 부모 Interactor을 Listener 인터페이스로 접근하게 됩니다.</p><h3>RIBs LifeCycle</h3><img width= "60%" alt="my-option" src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbpxXeS%2Fbtq2IkXxyk4%2Fpy5OqSBLtz0UUNbkdRAw3k%2Fimg.png"></img><ul><li>RIB의 Life cycle은 RIB이 Attach, Detach되는 상태가 존재합니다.</li></ul><img width= "60%" alt="my-option" src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbjTQ91%2Fbtq2HH6zXot%2FWLQuM9QXgRkO4nX8E7KAK0%2Fimg.png" ></img><ul><li>Router의 Animation설정이 필요하므로 Router에 Will, did에 관한 라이프사이클을 추가하면 사용하기 편리하게 만들 수 있습니다.</li></ul><h3>RIBs의 장단점</h3><h4>장점</h4><ul><li>“제대로 된 모듈화가 목적”이지만 VIPER는 그러지 않는 점이 존재</li><li>View의 Tree를 중심적으로 앱이 진행되는 단점, View에 의해 앱 상태가 동작되는 장점 → RIBs의 트리로 보완</li><li>View와 Business tree가 밀접하게 결합되어 있어, UI로직만 포함하거나 business 로직만 포함하는 노드를 구현하기 힘든 점<ul><li>RIBs는 Viewless RIB을 이용해서 Business Logic이 UI Logic에 종속되지 않게 만들 수 있습니다.</li></ul></li></ul><h4>단점</h4><ul><li>Boilerplate: 한 기능에 많은 클래스 수, 하나의 파일에 여러가지 클래스</li><li>Framework 의존성: RIBs라는 한 프레임워크에 프로젝트 전체가 종속</li></ul><h3>Template</h3><p><a href="https://github.com/uber/RIBs/tree/main/ios/tooling">공식 Template</a> | <a href="https://github.com/JiHoonAHN/Xcode-Template/tree/main/ModernRIBs%20or%20RIBs">직접 개선한 RIBs Template</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/posts/3</guid><title>Swift Compiler</title><description>How will Swift be compiled?</description><link>https://blog.jihoon.me/posts/3</link><pubDate>Fri, 21 Oct 2022 00:49:00 +0900</pubDate><content:encoded><![CDATA[<p>Swift 툴체인의 중심에는 Swift Compiler가 존재합니다.</p><p>Swift Compiler의 책임은 소스 코드를 실행할 수 있는 Object 코드로 변경시킵니다.</p><h3>Data Flow</h3><p>Swift Compiler는 LLVM이라는 Compiler의 기본구조에서 동작하며, 다음과 같은 data flow를 구성합니다.</p><p>Swift와 같은 high-level 언어를 machine code로 변환하는 과정은 Lowering이라는 실제 하드웨어에서 효과적으로 동작합니다.</p><p>둥근 코너의 사각형과 일반 사각형은 데이터의 Input 과 output을 나타내며, high level에서 부터 각각의 단계를 이해하는데 많은 도움을 줄 것입니다.</p><img width="100%"  alt="my-option" src="https://user-images.githubusercontent.com/68891494/196997871-4c97c0aa-c87a-475a-b79a-82b76d679bb7.png">
</img><ol><li>Parse : Swift 소스는 먼저 token들로 변환되고, AST(abstract syntax tree)에 들어가게 됩니다. 각각의 노드로 표현되는 트리라고 생각할 수 있습니다. 각 노드들은 소스들의 위치 정보를 함께 가지고 있기 떄문에 에러를 찾았을 때 각 노드는 정확하게 어디에서 문제가 발생했는지 말해줍니다.</li><li>Sematic Analysis(Sema): 해당 단계에서 컴파일러는 AST를 사용하여 프로그램의 의미를 분석합니다. 해당 단계에서 type checking이 일어납니다. 마찬가지로 AST를 사용하기 때문에 에러가 발생한 위치를 정확하게 짚어낼 수 있습니다. type check 완료 후 AST는 type-checked AST 상태가 되며, 이를 SILGen 단계로 전달하게 됩니다.<ul></ul></li></ol><ol start="3"><li>SILGen: 이 단계는 해당 단계를 가지지 않는 Clang 처럼 이전 컴파일러 파이프라인에서 벗어납니다. AST는 ASL(Swift Intermediate Language)로 lowered 됩니다. SIL은 basic block을 가지고 있는데, 이는 Swift Type, RC, Dispatch rules들과 computation을 가지고 있습니다. SIL은 raw와 canonical 두가지 특색을 가지고 있습니다. Canonical SIL은 raw SIL의 최소한의 최적화를 통한(모든 최적화를 진행하지 않아도) 결과입니다. SIL은 또한 소스의 위치 정보를 가지고 있기 때문에 의미있는 에러를 제공합니다.<ul></ul></li></ol><ol start="4"><li>IRGen: 이 도구는 SIL을 LLVM의 Intermediate Representation으로 lower 시킵니다. 이 시점의 instructions는 Swift만의 특성이 아닙니다. (모든 LLVM 기반은 이 representation을 사용합니다.) IR은 꽤 추상적입니다. SIL 처럼 IR은 Static Single Assignment(SSA) 형태입니다. IR은 무제한의 레지스터를 가진 machine처럼 모델링하고, 최적화를 찾기 쉽게 만듭니다. 또한 Swift type과는 무관합니다.<ul></ul></li></ol><ol start="5"><li>LLVM(Low Level Virtual Machine) : 최종 단계는 IR을 최적화 하고, 특정 플랫폼의 Machine의 명령어로 Lower를 진행합니다. 백엔드(machine 명령어를 방출하는것)에는 ARM, x86, Wasm 등이 포함됩니다. 위의 다이어그램은 Swift 컴파일러가 어떻게 object code를 생성하는지 보여줍니다. source code formatters, refactoring tools, documentation generators and syntax highlighters과 같은 도구들도 AST와 같은 중간 결과를 활용하여 최종 결과를 보다 견고하고 일관되게 만들 수 있습니다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/posts/2</guid><title>What is SwiftUI</title><description>Introducing what is SwiftUI!</description><link>https://blog.jihoon.me/posts/2</link><pubDate>Thu, 20 Oct 2022 17:02:00 +0900</pubDate><content:encoded><![CDATA[<p>2019년 애플의 WWDC에서 처음 소개된 SwiftUI 는 모든 애플 운영체제용 앱을 개발하는데 있어서 완전히 새로운 방법을 제공합니다.</p><p>SwiftUI의 기본적인 목적은 앱 개발을 더 쉽고 빠르게 함과 동시에 소프트웨어를 개발할 때 일반적으로 발생하는 버그들을 줄이는 것이다. 또한 개발 과젱어세도 앱의 라이브 프리뷰 기능을 이용하여 SwiftUI 프로젝트를 실시간으로 테스트할 수 있게 한다.</p><h2>SwiftUI의 선언적 구문</h2><p>UIKit과 인터페이스 빌더를 User Interface Layout을 설계하고 필요한 동작을 구현하는 것과는 완전히 다른 방법인 선언적 구문(declairactive syntax)이 SwiftUI에 도입되었다.</p><p>이 과정에서 기본적으로 레이아웃에 포함될 컴포넌트들을 선언하고, 그것들이 포함될 레이아웃 메니지 종류 (VStack, HStack, Form, List 등)를 명시하고, 속성을 설정하기 위해 수정자(modifier)를 사용한다.</p><p>이렇게 선언하고 난 후 레이아웃의 위치와 constraint그리고 렌더링 방법에 대한 모든 복잡한 세부 사항은 SwiftUI가 자동으로 처리한다.</p><p>SwiftUI 선언은 계층적으로 구조화 되어 있다. 따라서 복잡한 뷰를 보다 쉽게 생성할 수 있다.</p><h2>SwiftUI는 데이터 주도적</h2><p>SwiftUI 이전에는 앱 내에 있는 데이터의 현재 값을 검사하려면 그에 대한 코드를 앱에 포함해야했다.</p><p>시간에 지남에 따라 데이터가 변한다면 사용자 인터페이스가 데이터의 최신 상태를 항상 반영하도록 하는 코드를 작성하거나, 데이터가 변경되었는지 주기적으로 검사하는 코드를 작성하는 것, 그리고 갱신 메뉴를 제공해야했다. 이러한 데이터 소스를 앱의 여러 영역에서 사용할 경우 소스 코드의 복잡도가 증가한다.</p><p><strong>SwiftUI는 앱의 데이터 모델과 사용자 인터페이스 컴포넌트, 그리고 기능을 제공하는 로직을 binding하는 여러방법으로 복잡도를 해결한다.</strong></p><p>데이터 주도로 구현하면 데이터 모델은 앱의 다른 부분에서 subscibe 할 수 데이터 변수는 publish 하게 된다. (publisher – subsciber)</p><p>이러한 방법을 통해 데이터가 변경되었다는 사실을 모든 구독자에게 자동으로 알릴 수 있다.</p><p>만약 사용자 인터페이스 컴포넌트와 데이터 모델 간에 바인딩이 된다면, <strong>추가적인 코드를 작성하지 않아도 모든 데이터의 변경 사항을 SwiftUI가 사용자 인터페이스에 자동으로 반영할 것</strong>이다.</p><h2>UIKit VS SwiftUI</h2><p>사실 UIView와 SwiftUI를 함께 사용할 수 있는 방법은 다양하게 존재한다.</p><p>SwiftUI는 빠르고 효율적인 앱 개발 환경을 제공할 뿐만 아니라 코드를 크게 변경하지 않아도 다양한 애플 플랫폼에서 동일한 앱을 사용할 수 있게 한다. 하지만 지도 또는 웹 뷰를 통합해야 하는 특정 기능은 여전히 UIKit을 사용해야 한다.</p><p>또한, 매우 복잡한 UI 레이아웃을 설계하는 경우에 SwiftUI 레이아웃 컨테이너 뷰 사용이 만족스럽지 않을 수 있다.</p><p>이런상황에서는 인터페이스 빌더를 사용해야 할 수도 있다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/posts/1</guid><title>What is Swift</title><description>Introducing what is Swift!</description><link>https://blog.jihoon.me/posts/1</link><pubDate>Sun, 11 Apr 2021 07:02:00 +0900</pubDate><content:encoded><![CDATA[<p><a href="https://developer.apple.com/swift/">Apple 공식 Swift</a></p><p>스위프트는 iOS, macOS, watchOS, tvOS를 개발하기 위해 애플에서 제공하는 프로그래밍 언어 입니다.</p><h3>Swift의 특징</h3><p>애플이 최초에 스위프트를 발표했을 때 스위프트 언어의 특성을 Safe, Modern, Powerful 이라고 발표했습니다. 그러나 오픈소스로 전환되면서 특징을 Safe, Fast, Expressive로 변경하여 발표했습니다. 더불어 애플은 ‘스위프트는 보다 직관적이고 배우기 쉬운 언어’라고 스위프트를 소개했습니다. 먼저 애플이 발표한 스위프트의 언어적 특성을 항목별로 정리해 보았습니다.</p><h3>Safe</h3><p>스위프트는 안전한 프로그래밍을 지향합니다.</p><p>소프트웨어가 배포되기 전에, 즉 프로그래밍을 하는 중에 프로그래머가 저지를 수 있는 실수를 엄격한 문법을 통하여 미연에 방지하고자 노력했습니다. 때론 너무 강제적이라고 느껴질 수 있지만 문법적 제재는 실수를 줄이는 데 도움이 됩니다. 버그를 수정하거나 실수를 찾아내는 시간을 절약할 수 있습니다.</p><p>옵셔널이라는 기능을 비롯하여 guard 구문, 오류처리, 강력한 타입통제 등을 통해 스위프트는 안전한 프로그래밍을 구현하고 있습니다.</p><h3>Fast</h3><p>스위프트는 C 언어를 기반으로 한 C, C++, Objective-C와 같은 프로그래밍 언어를 대체하려는 목적으로 만들어졌습니다. 아직은 부분적으로 미흡하지만 성능 또한 C 언어 수준을 목표로 개발되었습니다. 그래서 스위프트는 성능을 예측할 수 있고 일정한 수준으로 유지할 수 있는 부분에 초점을 맞춰 개발되었습니다.</p><p>실행속도의 최적화 뿐만 아니라 컴파일러의 지속된 개량을 통해 더 빠른 컴파일 성능을 구현해 나가고 있습니다.</p><h3>Expressive</h3><p>스위프트는 여러 가지 프로그래밍 패러다임을 채용한 다중 패러다임 프로그래밍 언어입니다. 크게 보면 스위프트는 명령형 프로그래밍 패러다임, 객체지향 프로그래밍 패러다임, 함수형 프로그래밍 패러다임, 프로토콜 지향 프로그래밍 패러다임을 지향합니다. 정확하게는 명령형과 객체지향 프로그래밍 패러다임을 기반으로 한 함수형 프로그래밍 패러다임과 프로토콜 지향 프로그래밍 패러다임을 지향합니다. 결과적으로 스위프트에서 가장 강조하는 부분은 함수형 프로그래밍 패러다임과 프로토콜 지향 프로그래밍 패러다임입니다. 기존의 C 언어는 명령형 혹은 절자적 프로그래밍 패러다임을 채용했으며, C++, Java 등의 언어는 명령형 프로그래밍 패러다임과 객체지향 프로그래밍 패러다임을 동시에 채용한 다중 프로그래밍 패러다임 언어입니다.</p><p>최신 업데이트는 <a href="https://github.com/apple/swift/releases/tag/swift-5.7-RELEASE">5.7</a>입니다.</p><h2>Xcode Start</h2><p>Xcode는 iOS App 개발을 위한 IDE(통합 개발 환경, Integrated Development Environment) 입니다. iOS 뿐만 아니라 macOS, iPadOS, tvOS, watchOS... 등등 다양판 플랫폼을 제공할 수 있다.</p><p><a href="https://apps.apple.com/kr/app/xcode/id497799835?mt=12">AppStore</a></p><p>또는</p><p>명령어를 통해서 설치할 수 있습니다.</p><pre><code>xcode-select --install
</code></pre>]]></content:encoded></item></channel></rss>